#lang rosette/safe

; Chaper 3: syntactic forms

; (vc assumes asserts)
; where asserts = asserts || !assumes
; ie either program is correct or inputs are illegal

(define-symbolic a b c d boolean?)

#|
"""
Formally, (verify expr) searches for a model of the formula
(vc-assumes P) ∧ (vc-asserts P) ∧ (vc-assumes Q) ∧ ¬ (vc-asserts Q),
where P is the verification condition before the call to verify
and Q is the verification condition generated by evaluating expr.
"""

>(asssert x)
>(verify assert x)
returns unsat when you assert the same thing before the call & in expr because the assertions
will be x and ¬x
this also happpens when there is more than one var:
> (assert a)
> (assert b)
> (verify (assert b))
(unsat)
even though I expected (model [a #f] ...)

; other observations
order/interpolation of assumes and asserts matters

(verify assume y)
return unsat becuase there is no assertion inside the verify

> (assert a)
> (verify (assume a))
(unsat)
|#

; ==============================================

#|
"""
Formally, (solve expr) searches for a model of the formula
(vc-assumes P) ∧ (vc-asserts P) ∧ (vc-assumes Q) ∧ (vc-asserts Q),
where P is the verification condition before the call to solve and
 Q is the verification condition generated by evaluating expr.
"""

; in this example can look through all of the solutions by adding new assertions
excluding the solutions given
(assert a)
(assert (or b c))
> (solve (assert a))
(model
 [a #t]
 [b #t]
 [c #f])
> (solve (assert (not (and a b (not c)))))
(model
 [a #t]
 [b #f]
 [c #t])
> (solve (begin (assert (not (and a b (not c))))
                (assert (not (and a c (not b))))))
(model
 [a #t]
 [b #t]
 [c #t])
> (solve (begin (assert (not (and a b (not c))))
                (assert (not (and a c (not b))))
                (assert (not (and a b c)))))
(unsat)
|#



